/**
 * This ruleset enforces a security model for an internal store management system with Role-Based Access Control (RBAC).
 *
 * Core Philosophy:
 * The security model has two distinct domains:
 * 
 * 1. USER BUSINESS DATA (suppliers, customers, products, purchases, sales, invoices):
 *    - Any verified user can read/write their own data (per-user isolation via userId field)
 *    - Subscription-based restrictions (trial read-only) are handled at the application level
 *    - Admin role has NO access to user business data
 *
 * 2. ADMIN USER MANAGEMENT (users, accessRights):
 *    - Admins can create new user accounts
 *    - Admins can update user subscription (trial/premium), status, role
 *    - Admins can delete regular users but NOT other admin accounts
 *    - Admins can manage access rights and permissions
 *
 * Data Structure:
 * - Business data: /suppliers, /customers, /products, /purchases, /sales, /invoices
 * - User management: /users, /accessRights
 * - Shared: /notifications (per-user), /settings (per-user)
 *
 * Key Security Decisions:
 * - Email Verification Required: Users must verify their email before accessing any data
 * - Multi-Tenancy: All business data enforces userId isolation for data separation between users
 * - Admin Isolation: Admins manage accounts only; business data access is purely user-based
 * - Trial Expiry: Trial users lose write access after 5 days (role will be updated server-side)
 * - Relational Integrity: Subcollection items must correctly reference their parent documents
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated and verified
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Gets the user's document from the /users collection
     */
    function getUserDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    /**
     * Checks if user is verified (email verified)
     */
    function isEmailVerified() {
      return isSignedIn() && getUserDoc().emailVerified == true;
    }

    /**
     * Checks if user is admin
     */
    function isAdmin() {
      return isEmailVerified() && getUserDoc().role == 'admin';
    }

    /**
     * Checks if user is premium
     */
    function isPremium() {
      return isEmailVerified() && getUserDoc().subscription == 'premium';
    }

    /**
     * Checks if user is trial (regardless of expiry - server-side will handle expiry)
     */
    function isTrial() {
      return isEmailVerified() && getUserDoc().subscription == 'trial';
    }

    /**
     * Checks if user has write access (admin or premium)
     */
    function canWrite() {
      return isAdmin() || isPremium();
    }

    /**
     * Checks if user has read access (any verified user)
     */
    function canRead() {
      return isEmailVerified();
    }

    /**
     * Checks if the parent purchase document exists
     */
    function parentPurchaseExists(purchaseId) {
      return exists(/databases/$(database)/documents/purchases/$(purchaseId));
    }

    /**
     * Checks if the parent sale document exists
     */
    function parentSaleExists(saleId) {
      return exists(/databases/$(database)/documents/sales/$(saleId));
    }

    /**
     * Validates that a new purchase item's internal purchaseId matches its path
     */
    function hasValidPurchaseItemData(purchaseId) {
      return request.resource.data.purchaseId == purchaseId;
    }

    /**
     * Enforces that the purchaseId within a purchase item cannot be changed after creation
     */
    function isPurchaseItemImmutable() {
      return request.resource.data.purchaseId == resource.data.purchaseId;
    }

    /**
     * Validates that a new sale item's internal saleId matches its path
     */
    function hasValidSaleItemData(saleId) {
      return request.resource.data.saleId == saleId;
    }

    /**
     * Enforces that the saleId within a sale item cannot be changed after creation
     */
    function isSaleItemImmutable() {
      return request.resource.data.saleId == resource.data.saleId;
    }


    // --------------------------------------------------------------------
    // Users Collection Rules
    // --------------------------------------------------------------------

    /**
     * @description Manages user profiles and authentication data
     * @path /users/{uid}
     */
    match /users/{uid} {
      // Users can read their own profile
      allow read: if isSignedIn() && request.auth.uid == uid;
      // Users can create their own profile document (for initial signup)
      allow create: if isSignedIn() && request.auth.uid == uid;
      // Users can update their own profile (except role and subscription)
      // This allows updating displayName, photoURL and other profile fields.
      allow update: if isSignedIn() && request.auth.uid == uid && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role','subscription']);
      // Users cannot delete their own profile
      allow delete: if false;
    }

    /**
     * @description Admin user management
     * Admins have full control over user accounts with restrictions:
     * - Can create new user accounts
     * - Can update user subscription (trial/premium), status, role
     * - Can delete regular users but NOT other admin accounts
     * - Can read all user profiles
     */
    match /users/{uid} {
      // Admins can read all user profiles
      allow read: if isAdmin();
      
      // Admins can create new user documents
      allow create: if isAdmin();
      
      // Admins can update any user's details (subscription, status, role)
      // This allows admins to manage user subscriptions, suspend/activate users, and promote users to admin
      allow update: if isAdmin();
      
      // Admins can delete regular users but NOT other admin accounts (prevents accidental admin deletion)
      allow delete: if isAdmin() && resource.data.role != 'admin';
    }


    // --------------------------------------------------------------------
    // Collection Rules with RBAC
    // --------------------------------------------------------------------

    /**
     * @description Manages supplier data with per-user isolation and Git-like sync support
     * @access Any verified user can read/write their own suppliers
     * Each supplier document MUST have a userId field matching the authenticated user
     * 
     * Git-Like Sync Support:
     * - Suppliers now include version and updatedAt fields for conflict resolution
     * - userId field is required and immutable
     * 
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /suppliers/{supplierId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow update: if isEmailVerified() && 
                       resource.data.userId == request.auth.uid && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Manages customer data with per-user isolation and Git-like sync support
     * @access Any verified user can read/write their own customers
     * Each customer document MUST have a userId field matching the authenticated user
     * 
     * Git-Like Sync Support:
     * - Customers now include version and updatedAt fields for conflict resolution
     * - userId field is required and immutable
     * 
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /customers/{customerId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow update: if isEmailVerified() && 
                       resource.data.userId == request.auth.uid && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Manages product inventory with per-user isolation and Git-like sync support
     * @access Any verified user can read/write their own products
     * Each product document MUST have a userId field matching the authenticated user
     * 
     * Git-Like Sync Support:
     * - Products now include version and updatedAt fields for conflict resolution
     * - Soft deletes: documents marked with isDeleted=true instead of being removed
     * - Permanent deletes: documents completely removed from Firebase (from trash page)
     * - Last-write-wins: version and updatedAt fields track changes
     * - userId field is required and immutable
     * 
     * Deletion Flow:
     * 1. Soft Delete (Stock page): Marks product with isDeleted=true via update operation
     * 2. Restore (Trash page): Restores product by setting isDeleted=false via update operation
     * 3. Permanent Delete (Trash page): Completely removes document via delete operation
     * 
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /products/{productId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow update: if isEmailVerified() && 
                       resource.data.userId == request.auth.uid && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      // Allow soft delete (marked with isDeleted=true) and permanent delete (document removal)
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Manages purchase orders with per-user isolation and Git-like sync support
     * @access Any verified user can read/write their own purchases
     * Each purchase document MUST have a userId field matching the authenticated user
     * 
     * Git-Like Sync Support:
     * - Purchases now include version and updatedAt fields for conflict resolution
     * - userId field is required and immutable
     * 
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /purchases/{purchaseId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow update: if isEmailVerified() && 
                       resource.data.userId == request.auth.uid && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;

      /**
       * @description Manages line items within a purchase order
       * Users can only access purchase items from their own purchases
       */
      match /purchaseItems/{purchaseItemId} {
        allow read: if isEmailVerified() && get(/databases/$(database)/documents/purchases/$(purchaseId)).data.userId == request.auth.uid && parentPurchaseExists(purchaseId);
        allow create: if isEmailVerified() && get(/databases/$(database)/documents/purchases/$(purchaseId)).data.userId == request.auth.uid && parentPurchaseExists(purchaseId) && hasValidPurchaseItemData(purchaseId);
        allow update: if isEmailVerified() && get(/databases/$(database)/documents/purchases/$(purchaseId)).data.userId == request.auth.uid && parentPurchaseExists(purchaseId) && resource != null && isPurchaseItemImmutable();
        allow delete: if isEmailVerified() && get(/databases/$(database)/documents/purchases/$(purchaseId)).data.userId == request.auth.uid && parentPurchaseExists(purchaseId) && resource != null;
      }
    }

    /**
     * @description Manages sales to customers with per-user isolation and Git-like sync support
     * @access Any verified user can read/write their own sales
     * Each sale document MUST have a userId field matching the authenticated user
     * 
     * Git-Like Sync Support:
     * - Sales now include version and updatedAt fields for conflict resolution
     * - userId field is required and immutable
     * 
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /sales/{saleId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow update: if isEmailVerified() && 
                       resource.data.userId == request.auth.uid && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.version != null &&
                       request.resource.data.updatedAt != null;
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;

      /**
       * @description Manages line items within a sale
       * Users can only access sale items from their own sales
       */
      match /saleItems/{saleItemId} {
        allow read: if isEmailVerified() && get(/databases/$(database)/documents/sales/$(saleId)).data.userId == request.auth.uid && parentSaleExists(saleId);
        allow create: if isEmailVerified() && get(/databases/$(database)/documents/sales/$(saleId)).data.userId == request.auth.uid && parentSaleExists(saleId) && hasValidSaleItemData(saleId);
        allow update: if isEmailVerified() && get(/databases/$(database)/documents/sales/$(saleId)).data.userId == request.auth.uid && parentSaleExists(saleId) && resource != null && isSaleItemImmutable();
        allow delete: if isEmailVerified() && get(/databases/$(database)/documents/sales/$(saleId)).data.userId == request.auth.uid && parentSaleExists(saleId) && resource != null;
      }
    }

    /**
     * @description User notifications and Admin system notifications
     * @access Users can only read/update their own notifications; Admins create all notifications
     * Notification types: 'info', 'success', 'warning', 'error', 'alert' for users
     *                    'admin-system' for app manager system notifications
     */
    match /notifications/{notificationId} {
      // Users can read notifications sent to them (both user notifications and admin system notifications)
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      
      // Only admins can create notifications (for both users and other admins)
      allow create: if isAdmin();
      
      // Users and admins can update their own notifications (to mark as read)
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      
      // Admins or the notification owner can delete notifications
      allow delete: if isAdmin() || (isSignedIn() && resource.data.userId == request.auth.uid);
    }

    /**
     * @description Invoices collection with per-user isolation
     * @access Any verified user can read/write their own invoices
     * Each invoice document MUST have a userId field matching the authenticated user
     * Note: Subscription-based restrictions (trial read-only) are handled at application level
     */
    match /invoices/{invoiceId} {
      allow read: if isEmailVerified() && resource.data.userId == request.auth.uid;
      allow create: if isEmailVerified() && request.resource.data.userId == request.auth.uid;
      allow update: if isEmailVerified() && resource.data.userId == request.auth.uid && request.resource.data.userId == request.auth.uid;
      allow delete: if isEmailVerified() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Settings collection
     * @access Users can read/write their own settings; admins may manage all settings
     */
    match /settings/{settingId} {
      allow read: if isAdmin() || (isSignedIn() && request.auth.uid == settingId);
      allow write: if isAdmin() || (isSignedIn() && request.auth.uid == settingId);
    }

    /**
     * @description Access Rights collection - defines granular permissions for admin users
     * @access Only super admins can view, create, edit, delete access rights
     * Regular admins can only view available access rights for user assignment
     */
    match /accessRights/{accessRightId} {
      // All authenticated users can read access rights (needed for user assignment)
      allow read: if isSignedIn();
      
      // Only super admins can create new access rights
      // Super admin is identified by having 'accessRights.view' and 'accessRights.create' permissions
      allow create: if isAdmin() && isAccessRightsAdmin();
      
      // Only super admins can edit access rights
      allow update: if isAdmin() && isAccessRightsAdmin();
      
      // Only super admins can delete access rights
      allow delete: if isAdmin() && isAccessRightsAdmin();
    }
  }

  /**
   * Additional helper function for access rights admin check
   * This checks if the user has access rights management permissions
   */
  function isAccessRightsAdmin() {
    // For now, we check if user is super-admin (has all permissions including accessRights)
    // This will be validated at the application level through the AccessRightProfile
    return isAdmin();
  }
}